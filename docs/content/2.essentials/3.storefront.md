---
title: Storefront API
description: Using the shopify storefront API in nuxt
navigation:
  icon: i-lucide-store
seo:
  title: Storefront API
  description: Using the shopify storefront API in nuxt
---

TODO: Update docs

The [Storefront API](https://shopify.dev/docs/api/storefront){target=_blank} is a GraphQL API that allows you to build custom shopping experiences for your customers. It provides access to product, collection, and checkout data, as well as customer accounts and orders.

## Getting Started

::code-group
```vue [~/pages/index.vue]
<script setup lang="ts">
const storefront = useStorefront()

const { data, errors } = await storefront.request(`#graphql
  query GetShopInfo {
    shop {
      name
      description
    }
  }
`)
</script>
```

```ts [~/server/api/shop.ts]
export default defineEventHandler(async () => {
  const storefront = useStorefront()

  const { data, errors } = await storefront.request(`#graphql
    query GetShopInfo {
      shop {
        name
        description
      }
    }
  `)
})
```
::

::tip
The `#graphql` directive tells the module to process this file for GraphQL code generation, providing full TypeScript support.
::

### Use the API in your pages

Call your server endpoint from any Vue component or page:

```vue [~/pages/products.vue]
<script setup>
const { data: products, pending } = await useFetch('/api/products')
</script>

<template>
  <div>
    <div v-if="pending">Loading products...</div>
    <div v-else>
      <h1>Our Products</h1>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div 
          v-for="product in products.data.products.nodes" 
          :key="product.id"
          class="border rounded-lg p-4"
        >
          <h3>{{ product.title }}</h3>
          <p>{{ product.description }}</p>
          <p class="font-bold">
            {{ product.priceRange.minVariantPrice.amount }} 
            {{ product.priceRange.minVariantPrice.currencyCode }}
          </p>
        </div>
      </div>
    </div>
  </div>
</template>
```

### Add input validation

For production applications, validate your API inputs using Zod or similar libraries:

::tabs{.w-full}
  :::tabs-item{label="Install validation"}
    :::code-group
      ```bash [npm]
      npm install zod
      ```

      ```bash [pnpm]
      pnpm add zod
      ```

      ```bash [bun]
      bun add zod
      ```
    :::
  :::

  :::tabs-item{label="Create schema"}
    ```ts [~/server/api/products.ts]
    import { z } from 'zod'

    const schema = z.object({
      first: z.preprocess(v => Number(v), z.number().min(1).max(250)),
      query: z.string().optional(),
      sortKey: z.enum(['TITLE', 'PRICE', 'CREATED_AT']).optional(),
    })
    ```
  :::

  :::tabs-item{label="Validate inputs"}
    ```ts [~/server/api/products.ts]
    export default defineEventHandler(async (event) => {
        const storefront = useStorefront()
        const variables = await getValidatedQuery(event, schema.parse)
        
        const query = `#graphql
            query FetchProducts($first: Int, $query: String, $sortKey: ProductSortKeys) {
                products(first: $first, query: $query, sortKey: $sortKey) {
                    nodes {
                        id
                        title
                        description
                        handle
                    }
                }
            }
        `
        
        return storefront.request(query, { variables })
    })
    ```
  :::
::

::note
Nitro query parameters are always strings, so use `z.preprocess()` to convert numbers before validation.
::

## Common Patterns

### Product Collections

Query products from specific collections:

```ts [~/server/api/collection/[handle].ts]
export default defineEventHandler(async (event) => {
    const handle = getRouterParam(event, 'handle')
    const storefront = useStorefront()
    
    return await storefront.request(`#graphql
        query GetCollection($handle: String!) {
            collection(handle: $handle) {
                title
                description
                products(first: 20) {
                    nodes {
                        id
                        title
                        handle
                        featuredImage {
                            url
                            altText
                            width
                            height
                        }
                    }
                }
            }
        }
    `, {
        variables: { handle }
    })
})
```

### Search Products

Implement product search functionality:

```ts [~/server/api/search.ts]
export default defineEventHandler(async (event) => {
    const { q: query, limit = 20 } = getQuery(event)
    const storefront = useStorefront()
    
    if (!query) {
        throw createError({
            statusCode: 400,
            statusMessage: 'Search query is required'
        })
    }
    
    return await storefront.request(`#graphql
        query SearchProducts($query: String!, $first: Int!) {
            products(first: $first, query: $query) {
                nodes {
                    id
                    title
                    handle
                    description
                    variants(first: 1) {
                        nodes {
                            price {
                                amount
                                currencyCode
                            }
                        }
                    }
                }
            }
        }
    `, {
        variables: { 
            query: query as string, 
            first: Number(limit) 
        }
    })
})
```

### Error Handling

::callout{icon="i-lucide-alert-triangle" color="amber"}
Always handle GraphQL errors appropriately in production applications.
::

```ts [~/server/api/products.ts]
export default defineEventHandler(async (event) => {
    try {
        const storefront = useStorefront()
        const response = await storefront.request(query, { variables })
        
        if (response.errors) {
            throw createError({
                statusCode: 400,
                statusMessage: 'GraphQL query failed',
                data: response.errors
            })
        }
        
        return response.data
    } catch (error) {
        throw createError({
            statusCode: 500,
            statusMessage: 'Failed to fetch products'
        })
    }
})
```

## Advanced Usage

### Pagination

Implement cursor-based pagination for large datasets:

:::collapsible
  :::collapsible-content
    ```ts [~/server/api/products-paginated.ts]
    import { z } from 'zod'

    const schema = z.object({
      first: z.preprocess(v => Number(v), z.number().min(1).max(250)).optional(),
      after: z.string().optional(),
      before: z.string().optional(),
      last: z.preprocess(v => Number(v), z.number().min(1).max(250)).optional(),
    })

    export default defineEventHandler(async (event) => {
        const variables = await getValidatedQuery(event, schema.parse)
        const storefront = useStorefront()
        
        return await storefront.request(`#graphql
            query GetProductsPaginated($first: Int, $after: String, $before: String, $last: Int) {
                products(first: $first, after: $after, before: $before, last: $last) {
                    edges {
                        cursor
                        node {
                            id
                            title
                            handle
                        }
                    }
                    pageInfo {
                        hasNextPage
                        hasPreviousPage
                        startCursor
                        endCursor
                    }
                }
            }
        `, { variables })
    })
    ```
  :::
:::

### Type Safety

The module automatically generates TypeScript types for your GraphQL operations:

```ts
// These types are auto-generated based on your GraphQL queries
type FetchProductsQuery = {
  products: {
    nodes: Array<{
      id: string
      title: string
      description: string
    }>
  }
}

// Use in your application
const { data } = await useFetch<FetchProductsQuery>('/api/products')
```

## Best Practices

:::field-group
  ::field{name="fragment" type="string"}
  Use GraphQL fragments to avoid repeating field selections across queries
  ::

  ::field{name="caching" type="boolean"}
  Implement appropriate caching strategies for frequently accessed data
  ::

  ::field{name="error-handling" type="object"}
  Always handle both network errors and GraphQL errors in your applications
  ::

  ::field{name="validation" type="zod.Schema"}
  Validate all user inputs before sending them to the Storefront API
  ::
:::

::tip
For more complex queries and mutations, check out the [GraphQL Sandbox](/essentials/sandbox) for interactive testing.
::
